<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Firmar PDF</title>
  <style>
    #visorWrapper {
      position: relative;
      width: 600px;
      height: 800px;
      border: 1px solid #ccc;
    }
    #visorPdf {
      width: 600px;
      height: 800px;
      display: block;
      border: none;
    }
    #sigCanvas {
      position: absolute;
      top: 0; left: 0;
      /* NO poner width/height en CSS para evitar escalado */
      border: 1px solid transparent;
      cursor: crosshair;
    }
  </style>
</head>
<body>

  <h1>Firmar PDF</h1>

  <input type="file" id="pdfInput" accept="application/pdf" />

  <div id="visorWrapper">
    <iframe id="visorPdf"></iframe>
    <canvas id="sigCanvas"></canvas>
  </div>

  <button onclick="enviar()">Firmar y descargar</button>

  <script>
    const pdfInput = document.getElementById('pdfInput');
    const visorPdf = document.getElementById('visorPdf');
    const sigCanvas = document.getElementById('sigCanvas');

    // Ajustar canvas a resolución de pantalla para trazos suaves
    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.parentElement.getBoundingClientRect();

      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;

      canvas.style.width = rect.width + "px";
      canvas.style.height = rect.height + "px";

      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return ctx;
    }

    const ctx = setupCanvas(sigCanvas);

    let dibujando = false;

    function getMousePos(canvas, evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }

    sigCanvas.addEventListener('mousedown', e => {
      dibujando = true;
      const pos = getMousePos(sigCanvas, e);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
    });

    sigCanvas.addEventListener('mousemove', e => {
      if (!dibujando) return;
      const pos = getMousePos(sigCanvas, e);
      ctx.lineTo(pos.x, pos.y);
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 1.5;   // línea fina pero visible
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.stroke();
    });

    function detenerDibujo() {
      dibujando = false;
    }

    sigCanvas.addEventListener('mouseup', detenerDibujo);
    sigCanvas.addEventListener('mouseleave', detenerDibujo);

    pdfInput.addEventListener('change', () => {
      const file = pdfInput.files[0];
      if (file) {
        const url = URL.createObjectURL(file);
        visorPdf.src = url;
        // Limpiar firma anterior
        ctx.clearRect(0, 0, sigCanvas.width, sigCanvas.height);
      }
    });

    async function enviar() {
      const pdfFile = pdfInput.files[0];
      if (!pdfFile) {
        alert('Seleccioná un archivo PDF primero');
        return;
      }

      // Obtener firma en base64 PNG
      const firmaBase64 = sigCanvas.toDataURL('image/png');

      const formData = new FormData();
      formData.append('pdf', pdfFile);
      formData.append('firma', firmaBase64);
      formData.append('canvasWidth', sigCanvas.width);
      formData.append('canvasHeight', sigCanvas.height);

      try {
        const res = await fetch('/firmar-pdf', { method: 'POST', body: formData });
        if (!res.ok) throw new Error('Error en el servidor');
        const blob = await res.blob();

        // Descargar PDF firmado
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'pdf-firmado.pdf';
        a.click();

      } catch (error) {
        alert('Error al firmar el PDF: ' + error.message);
      }
    }
  </script>

</body>
</html>